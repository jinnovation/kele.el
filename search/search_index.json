{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83e\udd64 kele.el (Kubernetes Enablement Layer for Emacs)","text":"<p>Kele (k\u011b l\u00e8, or k\u0259-\u02c8l\u0259) (\u201cKubernetes Enablement Layer for Emacs\u201d) is a Kubernetes cluster management package. It empowers you to perform operations as coarse or fine-grained as you need, fast, and get back to your work.</p> <p>With Kele, you can:</p> <ul> <li>Manage contexts, e.g. switching, renaming, changing the default   namespace;</li> <li>Display details, follow   logs, and manage port-forwards for   resources;</li> <li>List collections of resources;</li> <li>Start and stop proxy servers;</li> <li>Use the menu bar to perform basic cluster/config management;</li> <li>Add an interactive modeline indicator with   <code>doom-modeline</code>;</li> <li>And more! </li> </ul> <p>See How-Tos &gt; Usage for more details on what\u2019s possible with Kele.</p> <p>Tip</p> <p>To learn more about how Kele compares to some other Kubernetes packages for Emacs, see: Explanations &gt; Comparisons with Similar Packages/Tools.</p> <p>Note</p> <p>Kele is not an official Kubernetes project.</p>"},{"location":"#screenshots","title":"Screenshots","text":"Resource listingResource-specific actionsMenu bar integration<code>doom-modeline</code> integration"},{"location":"#getting-started","title":"Getting Started","text":"<p>Kele requires Emacs 29+.</p> <pre><code>(use-package kele\n  :config\n  (kele-mode 1)\n  (bind-key (kbd \"s-k\") kele-command-map kele-mode-map))\n</code></pre> <p>By default this will load the package eagerly. This can be useful if you would like modeline integration to be always present. If, instead, you\u2019d like to lazily load the package, try the following, which will only load the package when you invoke the prefix keybinding:</p> <pre><code>(use-package kele\n  :config\n  (kele-mode 1)\n  :bind-keymap\n  (\"s-k\" . kele-command-map))\n</code></pre>"},{"location":"#about-the-name","title":"About the Name","text":"<p>The name Kele comes from the Mandarin term for cola, \u53ef\u4e50 (k\u011b l\u00e8). It is also an abbreviation of \u201cKubernetes Enablement Layer for Emacs.\u201d</p>"},{"location":"contributing/","title":"Contributor Guide","text":"<p>Info</p> <p>This page is a work-in-progress. More to come!</p> <p>Thanks for your interest in contributing to Kele! We\u2019re glad to have you. </p> <p>This page will give you all (well, most) of the information you\u2019ll need to get started.</p>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>Every symbol should be documented. This applies to both \u201cpublic\u201d (<code>kele-function-name</code>) and \u201cprivate\u201d (<code>kele--function-name</code>) symbols.</p> <p>Kele\u2019s documentation loosely follows the Diataxis framework.</p> <p>All new functionality should have corresponding user-facing documentation. Function docstrings are not a substitute for proper user-facing tutorials, usage instructions, etc.</p>"},{"location":"contributing/#changelog","title":"Changelog","text":"<p>We keep a changelog for Kele. Any change that is user-facing should be called out in the changelog.</p>"},{"location":"contributing/#architecture-decision-records-adrs","title":"Architecture Decision Records (ADRs)","text":"<p>We use architecture decision records (ADRs) in Kele very sparingly. Not every design decision made warrants an ADR of its own. As a contributor, you may be asked to write an ADR for your contribution, but only if it materially impacts Kele\u2019s user-facing behavior.</p>"},{"location":"contributing/#testing","title":"Testing","text":"<p>We use Buttercup to write tests.</p> <p>All PRs should have corresponding unit/integration tests. I am far more likely to review and generally consider your PR if it has tests.</p>"},{"location":"explanations/comparisons/","title":"Comparisons with Similar Packages/Tools","text":"<p>This page compares Kele with some of its peer packages.</p>"},{"location":"explanations/comparisons/#kubernetes-el","title":"kubernetes-el","text":"<p>Note</p> <p>The author of Kele is a co-maintainer of kubernetes-el.</p> <p>kubernetes-el is a Kubernetes cluster management package for Emacs. It draws heavy inspiration from Magit, from its \u201cstatus page\u201d-centric interface design down to its prevalent use of Transient-based keybindings.</p>"},{"location":"explanations/comparisons/#design-philosophy","title":"Design Philosophy","text":"<p>Kele draws heavy inspiration from kubernetes-el. It takes lessons learned during kubernetes-el development and strives for a cluster management experience that is lighter-weight, more agile, and more fluidly integrated with the native Emacs environment.</p> <p>Kele aims for a Kubernetes cluster management experience that is less intrusive, requires less context-switching, and is overall more performant than kubernetes-el.</p>"},{"location":"explanations/comparisons/#permissions","title":"Permissions","text":"<p><code>kubernetes-el</code> assumes a high level of privilege over the managed clusters, e.g. the ability to list namespaces. This is a simplifying assumption that obviously does not hold in all cases.</p> <p>Kele learns from this limitation by dynamically enabling/disabling specific keybindings depending on reported permissions from the cluster under management. For example, if you do not have permission to list Pods, then the <code>l</code> keybinding within the <code>kele-resource</code> Transient prefix will be disabled.</p>"},{"location":"explanations/comparisons/#support-for-custom-resources","title":"Support for custom resources","text":"<p>One of <code>kubernetes-el</code>\u2019s biggest limitations is its lack of support for custom resources. This limitation imposes a very low ceiling on the package\u2019s utility. The root causes extend to <code>kubernetes-el</code>\u2019s hard-coded and incomplete support for the Kubernetes core API (see <code>kubernetes-el/kubernetes-el#306</code>). Overhauling the associated design decisions would amount, in my co-maintainer\u2019s opinion, to a complete rewrite of <code>kubernetes-el</code> \u2013 hence my decision to kick off development on Kele.</p> <p>Kele was implemented to support custom resources from day one. To the fullest extent possible, \u201ccore\u201d resources (Pods, Deployments, etc.) are treated in exactly the same way as custom resources. Almost all resource-specific functionality, e.g. display logic and commands, are implemented generically.</p>"},{"location":"explanations/comparisons/#kubel","title":"kubel","text":"<p>kubel is a similar \u201cUI-centric\u201d cluster management package to kubernetes-el. Its advantage over kubernetes-el is its accommodation of users with limited privilege/permissions within the clusters in question.</p> <p>Similar to kubernetes-el, Kele focuses on providing a cluster management experience that is more \u201cpiecemeal\u201d (\u201cget this targeted piece of information as quickly as possible and move on with your life\u201d) and requires less context-switching \u2013 unavoidable with a status-page-centric user interface \u2013 than kubel.</p>"},{"location":"explanations/comparisons/#kubed","title":"kubed","text":"<p>Like Kele, Kubed is a Kubernetes management package for Emacs.</p> <p>Functionally, there is considerable overlap in functionality between Kele and Kubed. I highly encourage you to try both out and see which fits your workflow best! The differences between the two packages lie primarily in architecture and design.</p> <p>One of the biggest differences between Kele and Kubed is that the latter avoids 3rd-party dependencies. This makes it that much more feasible to add Kubed to core Emacs in the future, if desired. In general, Kubed aims to \u201cmake the most\u201d out of core Emacs integrations. For users that would like to minimize the number of transitive package dependencies they introduce to their workflow, this aspect of Kubed can be appealing.</p> <p>Conversely, Kele takes considerable liberty with its use of 3rd-party packages in the name of providing extended functionality. For example, Kele leveragess <code>plz.el</code> heavily in its direct communication with the Kubernetes API via HTTP using ephemeral proxy processes. This approach differs considerably from the other packages in this list, which by and large tend to rely on invoking the <code>kubectl</code> CLI in sub-processes and parsing the resulting shell output. We believe that the HTTP-API-based approach is not only more robust, but also allows for greater flexibility in the Emacs layer as a result. For example, this proxy-based architecture enables its universal support for custom resources from day one, treating them identically to core resources through generic implementation patterns.</p> <p>Similarly, Kele\u2019s dynamic permissions detection allows it to gracefully adapt functionality based on cluster-reported permissions, making it suitable for users with restricted cluster access while maintaining its \u201cpiecemeal\u201d philosophy of quickly retrieving targeted information with minimal context-switching. Conversely, Kubed is based around \u201cbinding\u201d package functionality to resources explicitly with the <code>kubed-define-resource</code> function, which introduces minor friction to scaling Kubed usage to all resources in a cluster.</p>"},{"location":"explanations/design/","title":"Design","text":"<p>This page goes into some of the design particulars of Kele. As an end user, feel free to explore at your curiosity, but rest assured that none of the information here is strictly necessary for your successful use of Kele.</p> <p>Tip</p> <p>This page may at times contain forward-looking statements, e.g. of design details that are upcoming but have not yet made their way into the main branch.</p>"},{"location":"explanations/design/#caches","title":"Caches","text":"<p>Kele revolves around two main in-memory caches:</p> <ul> <li>One that maintains the <code>kubeconfig</code> contents (<code>kele--kubeconfig</code>);</li> <li>One that maintains the discovery cache in-memory (<code>kele--discovery-cache</code>).</li> </ul> <p>Both of these caches are populated asynchronously on <code>kele-mode</code> initialization.</p> <p>The kubeconfig cache is kept in sync via a file watcher, which allows Kele to only incur read costs when they\u2019re actually needed. This is particularly useful for the <code>kubeconfig</code> cache, since the Kubeconfig itself is only occasionally modified in response to discrete user events, such as switching context or the default namespace for a given context. In combination with asynchronous IO via the <code>async</code> package, Kele is able to keep itself in sync with the underlying Kube configurations and caches without deadlocking users\u2019 Emacs environment.</p> <p>On the other hand, the discovery cache is timer-based and pulls the contents of the discovery cache from the filesystem at a set interval, as dictated by <code>kele-discovery-refresh-interval</code>.</p> <p>Why?</p> <p>We elect not to use file-watchers for the discovery cache due to the risk of completely exhausting the file descriptors Emacs can use. For more details, see <code>adr-01</code>.</p>"},{"location":"explanations/integrations/","title":"Integrations","text":"<p>Kele is well-integrated with the Emacs ecosystem.</p>"},{"location":"explanations/integrations/#menu-bar","title":"Menu Bar","text":"<p>Kele is integrated with the Emacs menu bar. The Kubernetes section lets you achieve many of the tasks that you\u2019d normally use keybindings for.</p> <p></p>"},{"location":"how-tos/customization/","title":"Customization","text":"<p>This page outlines the customization options available to you in Kele.</p>"},{"location":"how-tos/customization/#keybindings","title":"Keybindings","text":""},{"location":"how-tos/customization/#defining-a-keybinding-prefix","title":"Defining a keybinding prefix","text":"<p>Kele comes with a spread of recommended keybindings predefined as part of <code>kele-command-map</code>. <code>kele-command-map</code> is not assigned to a keybinding by default, so as to be minimally disruptive to your personal configurations.</p> <p>Using <code>kele-command-map</code>, you can choose your own keybinding to act as the keybinding prefix for all of Kele\u2019s keybindings.</p> <p>To bind, say, <code>s-k</code> as the keybinding prefix:</p> <pre><code>(define-key kele-mode-map (kbd \"s-k\") kele-command-map)\n</code></pre> <p>Now you can use, for example, <code>s-k c</code> to access context-related commands. Give it a try!</p>"},{"location":"how-tos/customization/#interface","title":"Interface","text":""},{"location":"how-tos/customization/#yaml-highlighting","title":"YAML highlighting","text":"<p>Kele automatically detects and enables YAML highlighting for <code>kele-get</code> when either:</p> <ul> <li><code>yaml-mode</code> is installed;</li> <li>The YAML Treesitter grammar is installed, in which case the   built-in <code>yaml-ts-mode</code> is used.</li> </ul> <p>You can hard-code the major mode you\u2019d like to use for YAML highlighting with the <code>kele-yaml-highlighting-mode</code> variable.</p> <p>If you\u2019d prefer, you can also disable YAML highlighting by setting <code>kele-yaml-highlighting-mode</code> to <code>nil</code>.</p>"},{"location":"how-tos/customization/#filtering-out-resource-fields-for-display","title":"Filtering out resource fields for display","text":"<p>When displaying a single resource with <code>kele-get</code>, <code>kele-get</code> retrieves the full manifest for the requested resource. This may include \u201cnoisy\u201d sub-fields like <code>.metadata.managedFields</code> or the <code>kubectl.kubernetes.io/last-applied-configuration</code> annotation that distract from the \u201cimportant\u201d bits.</p> <p>You can routinely filter out such fields using the <code>kele-filtered-fields</code> custom variable. For example, to filter out both of the above:</p> <pre><code>(setq kele-filtered-fields\n  '((metadata managedFields)\n    (metadata annotations kubectl.kubernetes.io/last-applied-configuration)))\n</code></pre>"},{"location":"how-tos/customization/#suppress-keybinding-instructions","title":"Suppress keybinding instructions","text":"<p>The results buffer for <code>kele-get</code> prints out a header blurb outlining the keybindings available to you. If this is distracting to you or offends your minimalist tendencies, use <code>kele-get-show-instructions</code> to disable printing of the <code>kele-get</code> result buffer\u2019s keybindings.</p> <pre><code>(setq kele-get-show-instructions nil)\n</code></pre>"},{"location":"how-tos/customization/#customizing-cache-behavior","title":"Customizing cache behavior","text":"<p>Kele provides a handful of customization variables with which you can influence cache behavior.</p>"},{"location":"how-tos/customization/#changing-resource-caching-expiration-time","title":"Changing resource caching expiration time","text":"<p>Note</p> <p>Currently only namespace names are cached.</p> <p>Kele caches certain resource names upon fetching. This speeds up subsequent queries drastically.</p> <p>These cached values have a expiration time, after which the cached values are erased.</p> <p>You can change the default refresh interval with <code>kele-resource-default-refresh-interval</code>. For example, a value of <code>60</code> means that all cached values are erased 60 seconds after creation.</p>"},{"location":"how-tos/customization/#changing-resource-specific-caching-expiration-time","title":"Changing resource-specific caching expiration time","text":"<p>For some resources, you might expect the set of names in the cluster to change more or less frequently than others. Some you might, for all intents and purposes, assume never change.</p> <p>You can set resource-specific cache expirations with <code>kele-resource-refresh-overrides</code>. For example, the following will set cached names for Pods to expire after 600 seconds:</p> <pre><code>(setq kele-resource-refresh-overrides '((pod . 600)))\n</code></pre> <p>You can also set the special value <code>:never</code>, in which case the cached values are never automatically erased once they\u2019re written. For example, the following will set cached names for Namespaces to never expire:</p> <pre><code>(setq kele-resource-refresh-overrides '((namespace . :never)))\n</code></pre>"},{"location":"how-tos/customization/#change-the-discovery-cache-polling-interval","title":"Change the discovery cache polling interval","text":"<p>If you\u2019d like Kele to poll the discovery cache more or less frequently than the default, set <code>kele-discovery-refresh-interval</code>, then disable and re-enable <code>kele-mode</code>.</p> <pre><code>(setq kele-discovery-refresh-interval)\n(kele-mode -1)\n(kele-mode +1)\n</code></pre> Known Issue <p>There is a potential for Kele\u2019s copy of the discovery cache to have outdated (relative to clusters\u2019 \u201ctrue\u201d state) information, even immediately after a poll. This is due to Kele\u2019s polling interval being separate from <code>kubectl</code>\u2019s own default TTL for the discovery cache, which is 10 minutes \u201clazily\u201d (that is, the cache is invalidated and its contents re-pulled at the next <code>kubectl</code> invocation after 10 minutes).</p> <p>Given Kele\u2019s extensive usage of <code>kubectl</code> under the hood, this should rarely present an actual issue to you as a user. If it does, consider pegging the value of <code>kele-discovery-refresh-interval</code> to hover roughly around 10 minutes. The default value of <code>kele-discovery-refresh-interval</code> is 600 seconds, i.e. 10 minutes.</p>"},{"location":"how-tos/integrations/","title":"Integrations","text":"<p>Kele contains several integrations with select packages.</p>"},{"location":"how-tos/integrations/#doom-modeline","title":"doom-modeline","text":"<p>Kele is integrated with <code>doom-modeline</code>. You can add a <code>k8s</code> segment to your modeline that displays the currently active context and, optionally, its default namespace. You can also access the menu bar from it.</p> <p> </p> <p>To get started, simply define a custom modeline with the <code>k8s</code> segment in it and set it as the default. For example:</p> <pre><code>(doom-modeline-def-modeline 'kele-modeline\n  '(bar matches buffer-info remote-host buffer-position parrot selection-info)\n  '(misc-info k8s minor-modes input-method buffer-encoding major-mode process vcs checker))\n\n(add-hook 'doom-modeline-mode-hook\n          (lambda ()\n            (doom-modeline-set-modeline 'kele-modeline 'default)))\n</code></pre> <p>See <code>doom-modeline</code> documentation for more nuanced use cases.</p>"},{"location":"how-tos/usage/","title":"Usage","text":"<p>Note</p> <p>You\u2019ll notice this page is pretty sparse. Kele is an early-stage package with lots of room to grow. Stay tuned for more!</p> <p>Note</p> <p>Kele doesn\u2019t have a default keybinding prefix for its commands. All examples documented here assume that you\u2019ve opted for <code>s-k</code>.</p> <p>For instructions on how to set your own keybinding prefix, see: How-Tos &gt; Customization.</p>"},{"location":"how-tos/usage/#dispatch","title":"Dispatch","text":"Keybinding Interactive function <code>s-k ?</code> <code>kele-dispatch</code> <p>Kele provides <code>kele-dispatch</code> as a launchpad for all subsequent Kele functionality. If you ever forget what the keybinding is for what you\u2019re trying to accomplish, reach for <code>kele-dispatch</code>.</p>"},{"location":"how-tos/usage/#working-with-resources","title":"Working with Resources","text":"<p><code>s-k r</code> will invoke <code>kele-resource</code>, allowing you to act on specific resource kinds. With <code>kele-resource</code>, you can, for example:</p> <ul> <li>Look up a given Kubernetes object by name, fetch its manifest, and display it   in a separate buffer;</li> <li>List out all resources of a given type.</li> </ul> <p></p> <p><code>kele-resource</code> supports custom resources too!</p> <p>Note</p> <p>Individual bindings within <code>kele-resource</code> are enabled/disabled based on your permissions in the given cluster. For example, if you do not have <code>get</code> permission for the given resource, the <code>g</code> key will be disabled \u2013 likewise the <code>l</code> key with <code>list</code> permission.</p> <p><code>kele-resource</code> will first prompt you to select the kind that you\u2019d like to work with, after which you can choose to get a specific object of that kind by name. If the resource is namespaced, you will also be presented with the option to choose the namespace to select from.</p> <p>Certain resource kinds have actions unique to them. When you select a resource kind that has such actions defined, these are presented in a dedicated section with their own key bindings. For example, <code>s-k r \"deployments\"</code> will, in addition to the general actions for getting and listing Deployments, also allow you to restart a specific Deployment.</p>"},{"location":"how-tos/usage/#getting-a-single-resource","title":"Getting a single resource","text":"<p>You can get a single resource of the given kind with: <pre><code>s-k r &lt;kind name&gt; g &lt;resource name&gt;\n</code></pre></p> <p>This is bound to <code>kele-get</code>.</p> <p>Tip</p> <p>Leaving <code>--namespace=</code> unset will list all resources of the selected kind across all namespaces for you to choose from.</p> Selecting a resourceViewing the chosen resource <p></p> <p></p>"},{"location":"how-tos/usage/#deleting-a-single-resource","title":"Deleting a single resource","text":"<p>You can delete a single resource of the given kind with: <pre><code>s-k r &lt;kind name&gt; d &lt;resource name&gt;\n</code></pre></p>"},{"location":"how-tos/usage/#listing-all-resources-of-a-single-kind","title":"Listing all resources of a single kind","text":"<p>You can list all resources of a single kind with: <pre><code>s-k r &lt;kind name&gt; l\n</code></pre></p> <p>This is bound to <code>kele-list</code>.</p> <p></p> <p>This will list all resources of the specified group-version and kind in a separate buffer in a table.</p> <p>Info</p> <p>Kele uses server-side printing, which means that any resource-specific columns that <code>kubectl</code> would print \u2013 for example, the \u201cStatus\u201d column for Pods \u2013 will be tabulated here as well.</p> <p>From here, you can:</p> <ul> <li>Click any of the header columns to sort the list;</li> <li>Click or hit <code>RET</code> on any of the entries to display its full manifest in a   separate buffer;</li> <li>Delete a resource with <code>k</code>.</li> </ul> <p>Tip</p> <p>Leaving <code>--namespace=</code> unset will list resources across all namespaces.</p> <p>Tip</p> <p>Hitting <code>RET</code> with your cursor on the Owner(s) column will open the owner resource.</p>"},{"location":"how-tos/usage/#refreshing-a-resource","title":"Refreshing a resource","text":"<p>You can press <code>g</code> in a <code>kele-get</code> buffer to re-fetch and refresh the current resource.</p>"},{"location":"how-tos/usage/#following-logs","title":"Following logs","text":"<p>When <code>kele-resource</code> is called on a resource that supports logs, you can use the <code>l</code> key to follow the logs for a single resource.</p> <p></p>"},{"location":"how-tos/usage/#contexts","title":"Contexts","text":"<p>Kele commands involving Kubernetes contexts center around the <code>s-k c</code> prefix (<code>kele-config</code>).</p> Keybinding Functionality Interactive function Demo <code>s-k c s</code> Switching from one context to another <code>kele-context-switch</code> <code>s-k c r</code> Renaming a context <code>kele-context-rename</code> <code>s-k c d</code> Deleting a context <code>kele-context-delete</code> <code>s-k c n</code> Changing the default namespace <code>kele-namespace-switch-for-current-context</code> <p>Tip</p> <p>Most context-related Kele functionality can also be done via Embark on any completion candidate in any context-related Kele command.</p> <p>Tip</p> <p>If you have functions that need to run after switching to a new context in order to use it, <code>kele-context-after-switch-functions</code> is available to use. This can be useful for, say, re-authenticating with the new context before interacting with it.</p>"},{"location":"how-tos/usage/#managing-proxy-servers","title":"Managing proxy servers","text":"<p>Kele allows for starting and stopping HTTP proxies for each context. The status of each context\u2019s proxy is displayed in the annotations for each cluster completion candidate.</p> Demo <p></p> <p>Note</p> <p>Any proxy server created via Kele is ephemeral; they are automatically closed and terminated after a set amount of time. For more details, see <code>kele-proxy-ttl</code>.</p> <p>Note</p> <p>Each context can only have one proxy server active at a time. This is an artificial limitation put in place by Kele.</p> Keybinding Functionality Interactive function <code>s-k p p</code> Start/stop proxy server process for the current context <code>kele-proxy-toggle</code> <code>s-k p P</code> Start/stop proxy server process for a specific context <code>kele-proxy-toggle</code>"},{"location":"references/","title":"References","text":"<p>This section contains technical descriptions of the inner workings and development of Kele. As a user, you will rarely if ever need to read these contents; you\u2019ll know if/when you do.</p>"},{"location":"references/changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented here.</p> <p>The format is based on Keep a Changelog, and this project adheres to semantic versioning.</p>"},{"location":"references/changelog/#unreleased","title":"Unreleased","text":""},{"location":"references/changelog/#added","title":"Added","text":"<ul> <li><code>kele-list-all</code> for listing all resource kinds defined in <code>kele-all-kinds</code> in a single buffer,   organized by kind. Accessible via <code>kele-dispatch</code> (bound to <code>L</code>)</li> <li><code>kele-list</code> buffer now displays the Last Updated time</li> <li>Resource kind completion is now grouped by API group. For example, Deployments, DaemonSets, and   ReplicaSets are all grouped under <code>apps</code> in the completion buffer.</li> <li>Resource name completion is now grouped by namespace for functions like <code>kele-get</code> or   <code>kele-delete</code> that operate on a single resource.</li> <li><code>kele-list</code> now uses collapsible sections with vtables inside, similar to Magit\u2019s status buffer.   The resource kind name is used as the section heading.</li> <li>Added dependency on <code>magit-section</code></li> <li>Added dedicated face <code>kele-resource-kind-face</code> for highlighting Kubernetes resource kinds,   replacing generic <code>warning</code> face usage</li> <li>Added dedicated keybindings + functions for initializing <code>kele-resource</code> to work with Pods,   Services, and Deployments</li> </ul>"},{"location":"references/changelog/#fixed","title":"Fixed","text":"<ul> <li><code>kele-proxy-stop</code>: Interactive completion now filters out contexts without active proxy processes</li> <li><code>kele-port-forward</code> is now inapt if the user does not have permission to create port-forwards</li> <li><code>kele-resource-follow-logs</code> is now inapt if the user does not have permission to get pod logs</li> <li>Fixed a regression where, in <code>kele-list-mode</code> buffers created via the <code>kele-list-all</code> function,   users were unable to <code>get</code> a row resource by hitting <code>RET</code> on it.</li> </ul>"},{"location":"references/changelog/#changed","title":"Changed","text":"<ul> <li><code>kele-get</code> now accepts a prefix argument (<code>C-u M-x kele-get</code>) to enable namespace   filtering. Without the prefix argument, <code>kele-get</code> searches across all namespaces.</li> </ul>"},{"location":"references/changelog/#removed","title":"Removed","text":"<ul> <li>Removed dependency on <code>s.el</code></li> </ul>"},{"location":"references/changelog/#070","title":"0.7.0","text":""},{"location":"references/changelog/#added_1","title":"Added","text":"<ul> <li><code>kele-list</code> now supports kind-specific columns. For example, listing   Deployments will now show columns <code>READY</code>, <code>UP-TO-DATE</code>, and <code>AVAILABLE</code>,   similar to <code>kubectl get deployments</code>. This is done via server-side printing,   meaning that you are guaranteed to see exactly the same thing as you\u2019d get   with <code>kubectl</code></li> <li><code>kele-resource</code> now has a keybinding to follow logs for resources that support   it</li> <li><code>kele-resource</code> now has a suffix for port-forwarding to resources that support   it, with completion on the given resource\u2019s configured ports</li> <li>Implemented <code>kele-kill-port-forward</code> for terminating port-forwards that were   created using <code>kele-port-forward</code></li> <li>Rename <code>kele-proxy</code> to <code>kele-ports</code></li> </ul>"},{"location":"references/changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Fixed <code>kele-transient</code> using non-existent <code>kele-proxy</code> instead of <code>kele-ports</code></li> <li>Context rename and delete operations now properly update all affected caches</li> <li><code>kele-get</code> now correctly renders inapt for resources that don\u2019t support the   <code>get</code> verb (e.g., <code>bindings</code>) (#81)</li> <li><code>kele-list</code> now correctly renders inapt for resources that don\u2019t support the   <code>list</code> verb</li> <li><code>kele-resource</code> now no longer displays the resource-specific suffixes section if the chosen   resource does not have any such suffix.</li> </ul>"},{"location":"references/changelog/#changed_1","title":"Changed","text":"<ul> <li>Renamed <code>kele-after-context-switch-hook</code> to   <code>kele-context-after-switch-functions</code>. Each member of this variable is now   expected to take the new context name as the sole argument (previously, they   took no arguments).</li> <li><code>kele-delete</code> now warns you when you\u2019re about to delete a \u201cdangerous\u201d   resource, e.g. namespaces that can have unintended cascading effects when   deleted</li> </ul>"},{"location":"references/changelog/#removed_1","title":"Removed","text":"<ul> <li>Removed unused dependency <code>ht</code></li> </ul>"},{"location":"references/changelog/#060","title":"0.6.0","text":""},{"location":"references/changelog/#added_2","title":"Added","text":"<ul> <li>Implemented <code>kele-deployment-restart</code> for restarting Deployments.</li> <li><code>kele-resource</code> now has a dedicated section for kind-specific actions that   populates based on the resource kind you selected.</li> <li>Added ability to <code>delete</code> individual resources via <code>kele-resource</code> and   <code>kele-list</code></li> <li>Added variable for selecting which YAML major mode function to use for YAML   highlighting in resource buffers</li> <li>Added output to <code>kele-list</code> buffers indicating the context</li> <li>Added additional columns to <code>kele-list</code> output, e.g. owner references</li> <li>In a <code>kele-list</code> table, <code>RET</code> now either opens the corresponding resource   or the owning resource, depending on cursor position</li> <li>Added binding <code>g</code> for refreshing a <code>kele-list</code> buffer</li> <li><code>kele-resource</code> now allows <code>--namespace=</code> to be unset. Resulting behavior is   suffix-specific. For example, nil <code>--namespace=</code> for <code>kele-list</code> will list   resources across all namespaces, while <code>kele-get</code> will do similarly for   completion/selection.</li> </ul>"},{"location":"references/changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Fixed a bug where kubeconfig cluster entries with uppercase letters in the   server address erroneously cause resource kind completion to silently fail and   show no kinds present in cluster</li> <li>Fixed a bug in <code>kele-resource</code> where the improper singular/plural form of the   resource name is used, e.g. \u201cGet a single pods\u201d instead of \u201cGet a single pod\u201d</li> <li>Fixed a bug where keybinding explanation \u201cblurbs\u201d in <code>kele-get</code> buffers don\u2019t   properly show the keybinding in clickable form</li> <li>Fixed a bug where keybindings in <code>kele-get-mode</code> are not actually bound</li> <li>Fixed a bug where empty results when listing resources e.g. for <code>kele-list</code> or   completion in <code>kele-get</code> results in false errors</li> </ul>"},{"location":"references/changelog/#changed_2","title":"Changed","text":"<ul> <li>Added dependency <code>memoize</code></li> <li>The <code>kele-resource</code> suffixes now disable themselves if you don\u2019t have the   required permissions. For example, if you don\u2019t have permission to <code>list</code>   Pods, the <code>l</code> keybinding will be grayed out and inaccessible.</li> <li>Migrated <code>kele-list</code> to   <code>vtable.el</code></li> <li>Bumped dependency <code>plz</code> from <code>0.7.3</code> to <code>0.8.0</code></li> </ul>"},{"location":"references/changelog/#removed_2","title":"Removed","text":"<ul> <li>Removed support for Emacs 28</li> </ul>"},{"location":"references/changelog/#050","title":"0.5.0","text":""},{"location":"references/changelog/#added_3","title":"Added","text":"<ul> <li>Menu bar integration. Now you can access common tasks via the   Kubernetes section on the menu bar</li> <li>Added ability to switch contexts from within the menu bar; available contexts   are shown as a sub-menu</li> <li>Added ability to switch the default namespace of the current context from   within the menu bar; available namespaces are shown as a sub-menu</li> <li>Added ability to specify that cached names of a specific resource should never   expire</li> </ul>"},{"location":"references/changelog/#fixed_3","title":"Fixed","text":"<ul> <li>Fixed a bug where a proxy server is sometimes initialized on a privileged   port, resulting in TCP <code>permission denied</code> errors</li> </ul>"},{"location":"references/changelog/#changed_3","title":"Changed","text":"<ul> <li>Changed the default cache expiration time for namespaces from 600 seconds to   never, since the set of namespaces in a cluster rarely if ever change. You   can use <code>kele-cache-namespaces</code> to force-refresh them as needed.</li> <li>Namespace selection now checks whether or not you have permission to list   namespaces from the cluster and falls back to verbatim string when you don\u2019t</li> </ul>"},{"location":"references/changelog/#042","title":"0.4.2","text":""},{"location":"references/changelog/#fixed_4","title":"Fixed","text":"<ul> <li>Fixed a bug where <code>kele-mode</code> errors out when the kubeconfig file does not   exist yet</li> <li>Fixed a bug where <code>curl</code> errors are not properly caught, resulting in attempts   to query the kubectl proxy server before it is ready</li> </ul>"},{"location":"references/changelog/#changed_4","title":"Changed","text":"<ul> <li>Bumped dependency <code>plz</code> from <code>0.3</code> to <code>0.7.3</code></li> </ul>"},{"location":"references/changelog/#removed_3","title":"Removed","text":"<ul> <li>Removed integration with <code>awesome-tray</code></li> </ul>"},{"location":"references/changelog/#041","title":"0.4.1","text":""},{"location":"references/changelog/#fixed_5","title":"Fixed","text":"<ul> <li>Fixed an issue where Kele can exhaust the number of file descriptors available for Emacs to use.</li> <li>Fixed an issue where command families that require proxy servers, e.g. <code>kele-resource</code>, result in false-positive   timeout errors when starting up the proxy server.</li> </ul>"},{"location":"references/changelog/#changed_5","title":"Changed","text":"<ul> <li>Discovery cache polling is now timer-based instead of \u201cdynamic,\u201d i.e. in response to filesystem changes.</li> </ul>"},{"location":"references/changelog/#040","title":"0.4.0","text":"<p>Lots of fun stuff in this release.</p> <p>Most importantly, Kele 0.4.0 introduces <code>kele-list</code> (<code>s-k &lt;resource type&gt; l</code>) and \u2013 with it \u2013 the ability to list all resources of a given type in tabulated form. Before, you could only fetch single resources. Now, with <code>kele-list</code>, you can create ad-hoc \u201coverviews\u201d of specific resource types within a given context and namespace; hitting Enter on any entry in this list brings up the resource\u2019s full manifest.</p> <p>Kele 0.4.0 also introduces the <code>kele-proxy</code> command palette (<code>s-k p</code>) for starting/stopping proxy servers for contexts. It also fleshes out the Kubeconfig management command palette (<code>s-k c</code>).</p> <p>For more details, see: How-Tos &gt; Usage.</p>"},{"location":"references/changelog/#added_4","title":"Added","text":"<ul> <li>Added a <code>kele-proxy</code> command prefix for managing proxy servers</li> <li>Added a keybinding to <code>kele-context</code> to enable/disable the proxy server for   the current context</li> <li>Added a keybinding to <code>kele-context</code> for deleting a context</li> <li>Added a keybinding to open <code>kele-kubeconfig-path</code> in a buffer</li> <li>Added a keybinding to <code>kele-resource</code> to support listing out all resources of   a given type (<code>kele-list</code>)</li> </ul>"},{"location":"references/changelog/#fixed_6","title":"Fixed","text":"<ul> <li><code>kele-context</code> and <code>kele-resource</code> now wait on kubeconfig sync completion to   finish if one is currently in progress</li> <li>Fixed a bug where force-enabling or force-disabling <code>kele-mode</code> (via either   <code>(kele-mode 1)</code> or <code>(kele-mode -1)</code>) when <code>kele-mode</code> is already active or   inactive (respectively) resulted in errors</li> <li>Fixed an issue where attempting to invoke <code>s-k &lt;resource name&gt; g</code> sometimes   results in the following error: <code>transient-setup: Suffix   transient:kele-resource::command is not defined or autoloaded as a command</code></li> </ul>"},{"location":"references/changelog/#changed_6","title":"Changed","text":"<ul> <li>Renamed <code>kele-context</code> to <code>kele-config</code></li> <li>Increased the default value of <code>kele-proxy-ttl</code> from <code>60</code> to <code>180</code></li> <li>Binding for <code>kele-get</code> in <code>kele-get-mode</code> changed from <code>U</code> to <code>g</code></li> </ul>"},{"location":"references/changelog/#030","title":"0.3.0","text":"<p>This release focuses on providing Kele\u2019s command palette and user interface with a scalable foundation for future growth. As Kele\u2019s spread of user-facing commands grows, it becomes less and less reasonable to expect users to <code>M-x</code> everything.</p> <p>To that end, this release adds the following:</p> <ul> <li>A Kele command keymap that will allow keybinding-based access to all   Kele-based functionality (see How-Tos &gt; Customization and How-Tos &gt; Usage   for more details)</li> <li>A spread of three Transient-based \u201cprefix\u201d commands \u2013 <code>kele-context</code>,   <code>kele-resource</code>, and <code>kele-dispatch</code> \u2013 for nested command discovery and   ad-hoc configuration, e.g. overriding the context and namespace to use for   resource fetching. Again, see How-Tos &gt; Usage for more details.</li> </ul> <p>I\u2019m optimistic that these two additions make Kele\u2019s user interface much more pleasant and nimble, while also giving it ample room to grow in complexity and scope in the coming releases.</p>"},{"location":"references/changelog/#added_5","title":"Added","text":"<ul> <li><code>kele-get</code> resource name input now supports completion! </li> <li><code>kele-get</code> buffers now have keybindings for quitting and killing the resource   display buffer</li> <li>You can now press <code>U</code> in <code>kele-get</code> buffers to re-fetch and refresh the   current resource</li> <li><code>kele-get</code> buffers\u2019 front matter now outlines the available keybindings</li> <li>Added a <code>kele-dispatch</code> command for when you forget the specific keybinding of   what you\u2019re trying to accomplish</li> <li>Added a <code>kele-context</code> command prefix for context-related actions</li> <li>Added a <code>kele-resources</code> command prefix for acting on specific resource kinds,   e.g. <code>get</code>ting, with support for selecting the context, namespace, and the   group-version to use (in cases of ambiguity)</li> </ul>"},{"location":"references/changelog/#changed_7","title":"Changed","text":"<ul> <li>Added dependency: <code>s</code></li> <li>Removed dependency: <code>requests</code></li> <li>Increased minimum required Emacs version to 28.1</li> </ul>"},{"location":"references/changelog/#021","title":"0.2.1","text":"<p>This release focuses on refining the <code>kele-get</code> experience \u2013 usability improvements and general bugfixes.</p>"},{"location":"references/changelog/#added_6","title":"Added","text":"<ul> <li><code>kele-get</code> buffers now have a dedicated minor mode, <code>kele-get-mode</code>.</li> <li><code>kele-get</code> buffers now print a header detailing, for the resource under   display: the context it was fetched from; and the time of retrieval</li> <li>Added a custom variable <code>kele-filtered-fields</code> with which you can routinely   filter out resource fields from display in <code>kele-get</code></li> </ul>"},{"location":"references/changelog/#fixed_7","title":"Fixed","text":"<ul> <li>Fixed an issue where <code>kele-get</code> results buffer incorrectly prints namespace   for un-namespaced resources as <code>nil</code></li> <li>Fixed an issue where <code>kele-get</code> refused to display the retrieved resource, if   a buffer corresponding to that resource already exists</li> </ul>"},{"location":"references/changelog/#changed_8","title":"Changed","text":"<ul> <li><code>kele-get</code> completion for the resource type now only returns resources that   support the <code>get</code> verb</li> </ul>"},{"location":"references/changelog/#020","title":"0.2.0","text":"<p>This release introduces <code>kele-get</code> \u2013 <code>kubectl get</code>, the Emacs way . With <code>kele-get</code> you can interactively specify the kind and name of the resource that you\u2019d like to <code>get</code> and display its manifest in a separate buffer. What\u2019s more, it supports custom resources right out the gate \u2013 a long-standing functionality gap in <code>kubernetes-el</code>.</p> <p>See How-Tos &gt; Usage &gt; Working with Resources for details and a demo GIF. It\u2019s very much an MVP so there are some rough edges. Please open an issue for any peculiar behavior that you notice.</p>"},{"location":"references/changelog/#added_7","title":"Added","text":"<ul> <li>Implemented <code>kele-get</code> for interactively getting and displaying a given   resource</li> <li>Context annotations now display whether a proxy server is currently active for   the given context</li> <li>Implemented interactive functions for per-context proxy server management:   <code>kele-proxy-start</code>, <code>kele-proxy-stop</code>, and <code>kele-proxy-toggle</code></li> </ul>"},{"location":"references/changelog/#fixed_8","title":"Fixed","text":"<ul> <li>Fixed an issue where disabling <code>kele-mode</code> resulted in an error reporting   unbound slot <code>filewatch-id</code> on <code>kele--discovery-cache</code></li> <li>Fixed an issue where cluster servers with ports,   e.g. <code>https://127.0.0.1:51134</code>, were not recognized properly</li> <li>Fixed an issue where namespace completion candidates failed to populate on   initial fetch of said namespaces from the Kubernetes API</li> </ul>"},{"location":"references/changelog/#changed_9","title":"Changed","text":"<ul> <li>Buffer for contexts\u2019 proxy processes are now hidden</li> <li>Default value for <code>kele-cache-dir</code> is now <code>~/.kube/cache</code>; before it was   relative to the value of <code>kele-kubeconfig-path</code> (and unreliably so)</li> </ul>"},{"location":"references/changelog/#011","title":"0.1.1","text":""},{"location":"references/changelog/#added_8","title":"Added","text":"<ul> <li>Kubeconfig file watching is now asynchronous and therefore non-blocking!</li> <li>Kubeconfig file watching now prints a progress report denoting when changes   were detected (and thus reading has begun asynchronously) and when reading has   completed</li> </ul>"},{"location":"references/changelog/#fixed_9","title":"Fixed","text":"<ul> <li>Fixed an issue where proxies were being created for the current context,   regardless of which context it was actually requested for</li> <li>Fixed an issue in <code>kele-namespace-switch-for-context</code> where the selection   candidates were pulled for the current context rather than the argument   context</li> <li>Fixed an issue where attempting to pull completion candidates via queries to   the proxy API server resulted in an error, as well as multiple proxy server   processes being inadvertently spun up for the same context</li> <li>Fixed an issue where custom kubeconfig path is not respected by <code>kubectl</code>   invocations</li> </ul>"},{"location":"references/changelog/#changed_10","title":"Changed","text":"<ul> <li>Added dependency: <code>plz</code></li> <li>Added dependency: <code>async</code></li> </ul>"},{"location":"references/changelog/#010","title":"0.1.0","text":"<p>Kele is born!</p> <p>This initial release of Kele has a very simple goal: \u201c<code>kubectx</code> and <code>kubens</code>, but make it Emacs.\u201d Its feature set is limited but lays the foundation \u2013 both in terms of implementation and \u201cdesign philosophy\u201d \u2013 for future enhancements.</p>"},{"location":"references/changelog/#added_9","title":"Added","text":"<ul> <li>Added ability to switch and rename contexts, with completion and caching</li> <li>Added ability to switch namespaces for any given context</li> </ul>"},{"location":"references/adrs/","title":"Architecture Decision Records (ADRs)","text":"<p>This section collects \u201carchitecture decision records (ADRs)\u201d for Kele. These are records of \u201carchitecturally significant\u201d decisions, that materially impact Kele\u2019s design and capabilities.</p> <p>Tip</p> <p>For more information about ADRs, see Michael Nygard\u2019s seminal post \u201cDocumenting Architecture Decisions\u201d.</p>"},{"location":"references/adrs/00-template/","title":"ADR 0000: [title]","text":""},{"location":"references/adrs/00-template/#status","title":"Status","text":""},{"location":"references/adrs/00-template/#context","title":"Context","text":""},{"location":"references/adrs/00-template/#decision","title":"Decision","text":""},{"location":"references/adrs/00-template/#consequences","title":"Consequences","text":""},{"location":"references/adrs/01-timer-based-discovery-cache/","title":"adr-01: Timer-based discovery-cache caching","text":""},{"location":"references/adrs/01-timer-based-discovery-cache/#status","title":"Status","text":"<p>Implemented in #150.</p>"},{"location":"references/adrs/01-timer-based-discovery-cache/#context","title":"Context","text":"<p>As of 2023-03-05, Kele uses a naive set of two separate caches:</p> <ul> <li>The \u201ckubeconfig cache,\u201d which brokers reads from the user\u2019s configured kubeconfig (<code>kele-kubeconfig-path</code>);</li> <li>The \u201cdiscovery cache,\u201d which brokers reads from the user\u2019s discovery cache.</li> </ul> <p>Note</p> <p>The latter, confusingly, shares the same name with the discovery cache that lives in the user\u2019s filesystem, typically under <code>~/.kube/cache/discovery</code>. We use \u201cdiscovery cache\u201d to refer specifically to the Kele data structure, and use \u201cfilesystem discovery cache\u201d to refer to the \u201cactual\u201d discovery cache.</p> <p>On enablement of <code>kele-mode</code>, Kele initializes both the kubeconfig cache and the discovery cache. The kubeconfig cache loads the contents of the user\u2019s <code>kubeconfig</code> file into memory; likewise, the discovery cache loads the contents of the user\u2019s filesystem discovery cache into memory. Both caches initialize [file watchers] that \u201cauto-refresh\u201d the respective cache contents on changes to the underlying file(s).</p> <p>The combined use of these two caches enables near-instant completion of:</p> <ul> <li>A user\u2019s contexts and other cluster configurations;</li> <li>The available API groups, versions, and kinds on a given cluster.</li> </ul>"},{"location":"references/adrs/01-timer-based-discovery-cache/#problems","title":"Problems","text":"<p>The aforementioned \u201call-at-once\u201d approach has proven to have several shortcomings.</p>"},{"location":"references/adrs/01-timer-based-discovery-cache/#gratuitous-file-watching","title":"Gratuitous File-Watching","text":"<p>The most fundamental problem is that the discovery cache does not scale. Emacs file-watching uses file descriptors under the hood, which Emacs has a [finite number available for use at any given time][1]. Exceeding this limit results in an error to the following effect:</p> <pre><code>File watching not possible, no file descriptor left: 975\n</code></pre> <p>This limit is, to my knowledge, not user-configurable. Even if it were, it is an unreasonably invasive thing to ask users to do \u2013 for an Emacs package of all things. Most notably, this limit is, like all things, shared globally within Emacs, e.g. by [LSP-Mode][lsp-mode] and [auto-revert-mode], making the \u201creal\u201d limit for Kele much lower. In order to be a \u201cgood Emacs citizen,\u201d Kele needs to be much more conservative and strategic in its use of file-watchers.</p> <p>We note that it is very easy to hit this limit. Anecdotally, I maintain kubectl access to a handful of production-scale clusters as part of my day job, and simply adding a couple more ad-hoc [Kind] clusters as part of integration-testing for this very package is enough for me to hit the limit. Doing so requires me to manually delete the filesystem discovery cache directories corresponding to these transient Kind clusters On top of being annoying, this is also a fundamentally unreasonable workaround; what happens if a user simply has that many clusters to maintain?</p>"},{"location":"references/adrs/01-timer-based-discovery-cache/#decision","title":"Decision","text":"<p>The simplest and \u201cstupidest\u201d solution to this problem is to make caching of the filesystem discovery cache timer-based rather than filewatch-based.</p>"},{"location":"references/adrs/01-timer-based-discovery-cache/#consequences","title":"Consequences","text":"<p>This approach represents, to an extent, a \u201cregression\u201d of sorts in the functionality of the discovery cache, as now the contents thereof are not guaranteed to be fully up-to-date with those of the filesystem dicovery cache. We decide that this is safe, as the set of group-version-kinds present in a cluster are unlikely to change that frequently. This is consistent with <code>kubectl</code>\u2019s own refresh policy for the filesystem discovery cache, which refills the cache every ten minutes \u2013 and lazily, at that, i.e. on the next user invocation of <code>kubectl</code> after the ten-minute mark.</p>"}]}